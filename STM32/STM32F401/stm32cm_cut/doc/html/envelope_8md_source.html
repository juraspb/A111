<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acconeer API: /home/ai/jenkins/workspace/sw-main@2/doc/user_guides/rss/envelope.md Source File</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Acconeer API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('envelope_8md.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">/home/ai/jenkins/workspace/sw-main@2/doc/user_guides/rss/envelope.md</div>  </div>
</div><!--header-->
<div class="contents">
<a href="envelope_8md.html">Go to the documentation of this file.</a><div class="fragment"><div class="line"><a name="l00001"></a><span class="lineno">    1</span>&#160;# Envelope Service {#envelope}</div><div class="line"><a name="l00002"></a><span class="lineno">    2</span>&#160;</div><div class="line"><a name="l00003"></a><span class="lineno">    3</span>&#160;The Envelope Service is one of four services that provides an interface for reading out the radar signal from the Acconeer A111 sensor. The data returned from the Envelope service is typically further processed and can be used in different types of algorithms such as distance measurement algorithms, motion detection algorithms, and object positioning algorithms. In use cases where low computation complexity is important, and the exact location of objects is less important you may consider using the power bins service instead of the Envelope service. Advanced users that needs phase information for detecting very small variations in distance will probably prefer the IQ data service instead of the envelop service. Users which are interested in detection of any movement, small or large, occurring in front of the sensor can instead use our sparse service.</div><div class="line"><a name="l00004"></a><span class="lineno">    4</span>&#160;</div><div class="line"><a name="l00005"></a><span class="lineno">    5</span>&#160;![](RSS_stack.png)</div><div class="line"><a name="l00006"></a><span class="lineno">    6</span>&#160;</div><div class="line"><a name="l00007"></a><span class="lineno">    7</span>&#160;Acconeer also provide several easy to use detectors that are implemented on top of the basic data services. The detectors provide an interface for higher level tasks like distance measurements, motion detection etc.</div><div class="line"><a name="l00008"></a><span class="lineno">    8</span>&#160;</div><div class="line"><a name="l00009"></a><span class="lineno">    9</span>&#160;Acconeer provides an example of how to use the Envelope service: example_service_envelope.c</div><div class="line"><a name="l00010"></a><span class="lineno">   10</span>&#160;</div><div class="line"><a name="l00011"></a><span class="lineno">   11</span>&#160;For more details on the Envelope data it is recommended to use our exploration tool. Check it out on [github](https://github.com/acconeer/acconeer-python-exploration), https://github.com/acconeer/acconeer-python-exploration.</div><div class="line"><a name="l00012"></a><span class="lineno">   12</span>&#160;</div><div class="line"><a name="l00013"></a><span class="lineno">   13</span>&#160;## Disclaimer</div><div class="line"><a name="l00014"></a><span class="lineno">   14</span>&#160;</div><div class="line"><a name="l00015"></a><span class="lineno">   15</span>&#160;Profile 3-5 will not have optimal performance using A111 with batch number 10467, 10457 or 10178 (also when mounted on XR111 and XR112). XM112 and XM122 are not affected since they have A111 from other batches.</div><div class="line"><a name="l00016"></a><span class="lineno">   16</span>&#160;</div><div class="line"><a name="l00017"></a><span class="lineno">   17</span>&#160;# Setting up the Service</div><div class="line"><a name="l00018"></a><span class="lineno">   18</span>&#160;</div><div class="line"><a name="l00019"></a><span class="lineno">   19</span>&#160;## Initializing the System</div><div class="line"><a name="l00020"></a><span class="lineno">   20</span>&#160;</div><div class="line"><a name="l00021"></a><span class="lineno">   21</span>&#160;The Radar System Software (RSS) must be activated before any other calls are done. The activation requires a pointer to an acc_hal_t  struct which contains information on the hardware integration and function pointers to hardware driver functions that are needed by RSS. See chapter 4 in the document “HAL  Integration User Guide” for more information on how to integrate to the driver layer and populate the hal struct.</div><div class="line"><a name="l00022"></a><span class="lineno">   22</span>&#160;</div><div class="line"><a name="l00023"></a><span class="lineno">   23</span>&#160;In Acconeer’s example integration towards STM32 and the drivers generated by the STM32Cube tool, there is a function acc_hal_integration_get_implementation to obtain the hal struct.</div><div class="line"><a name="l00024"></a><span class="lineno">   24</span>&#160;</div><div class="line"><a name="l00025"></a><span class="lineno">   25</span>&#160;```c</div><div class="line"><a name="l00026"></a><span class="lineno">   26</span>&#160;acc_hal_t hal = acc_hal_integration_get_implementation();</div><div class="line"><a name="l00027"></a><span class="lineno">   27</span>&#160;</div><div class="line"><a name="l00028"></a><span class="lineno">   28</span>&#160;if (!acc_rss_activate(&amp;hal))</div><div class="line"><a name="l00029"></a><span class="lineno">   29</span>&#160;{</div><div class="line"><a name="l00030"></a><span class="lineno">   30</span>&#160;   /* Handle error */</div><div class="line"><a name="l00031"></a><span class="lineno">   31</span>&#160;}</div><div class="line"><a name="l00032"></a><span class="lineno">   32</span>&#160;```</div><div class="line"><a name="l00033"></a><span class="lineno">   33</span>&#160;</div><div class="line"><a name="l00034"></a><span class="lineno">   34</span>&#160;The corresponding code looks slightly different in software packages for the Raspberry Pi and other software packages from Acconeer where peripheral drivers for the host are included. The driver layer is first initialized by calling acc_driver_hal_init. The hal struct is then obtained with the function acc_driver_hal_get_implementation.</div><div class="line"><a name="l00035"></a><span class="lineno">   35</span>&#160;</div><div class="line"><a name="l00036"></a><span class="lineno">   36</span>&#160;```c</div><div class="line"><a name="l00037"></a><span class="lineno">   37</span>&#160;if (!acc_driver_hal_init())</div><div class="line"><a name="l00038"></a><span class="lineno">   38</span>&#160;{</div><div class="line"><a name="l00039"></a><span class="lineno">   39</span>&#160;   /* Handle error */</div><div class="line"><a name="l00040"></a><span class="lineno">   40</span>&#160;}</div><div class="line"><a name="l00041"></a><span class="lineno">   41</span>&#160;</div><div class="line"><a name="l00042"></a><span class="lineno">   42</span>&#160;acc_hal_t hal = acc_driver_hal_get_implementation();</div><div class="line"><a name="l00043"></a><span class="lineno">   43</span>&#160;</div><div class="line"><a name="l00044"></a><span class="lineno">   44</span>&#160;if (!acc_rss_activate(&amp;hal))</div><div class="line"><a name="l00045"></a><span class="lineno">   45</span>&#160;{</div><div class="line"><a name="l00046"></a><span class="lineno">   46</span>&#160;   /* Handle error */</div><div class="line"><a name="l00047"></a><span class="lineno">   47</span>&#160;}</div><div class="line"><a name="l00048"></a><span class="lineno">   48</span>&#160;```</div><div class="line"><a name="l00049"></a><span class="lineno">   49</span>&#160;</div><div class="line"><a name="l00050"></a><span class="lineno">   50</span>&#160;## Service API</div><div class="line"><a name="l00051"></a><span class="lineno">   51</span>&#160;</div><div class="line"><a name="l00052"></a><span class="lineno">   52</span>&#160;All services in the Acconeer API are created and activated in two distinct steps. In the first creation step the configuration settings are evaluated and all necessary resources are allocated. If there is some error in the configuration or if there are not enough resources in the system to run the service, the creation step will fail. However, when the creation is successful you can be sure that the second activation step will not fail due to any configuration or resource issues. When the service is activated the radar is activated and can start producing data.</div><div class="line"><a name="l00053"></a><span class="lineno">   53</span>&#160;</div><div class="line"><a name="l00054"></a><span class="lineno">   54</span>&#160;## Envelope Service Configuration</div><div class="line"><a name="l00055"></a><span class="lineno">   55</span>&#160;</div><div class="line"><a name="l00056"></a><span class="lineno">   56</span>&#160;Before the Envelope service can be created and activated, we must prepare a service configuration. First a configuration is created.</div><div class="line"><a name="l00057"></a><span class="lineno">   57</span>&#160;</div><div class="line"><a name="l00058"></a><span class="lineno">   58</span>&#160;```c</div><div class="line"><a name="l00059"></a><span class="lineno">   59</span>&#160;acc_service_configuration_t envelope_configuration = acc_service_envelope_configuration_create();</div><div class="line"><a name="l00060"></a><span class="lineno">   60</span>&#160;</div><div class="line"><a name="l00061"></a><span class="lineno">   61</span>&#160;if (envelope_configuration == NULL)</div><div class="line"><a name="l00062"></a><span class="lineno">   62</span>&#160;{</div><div class="line"><a name="l00063"></a><span class="lineno">   63</span>&#160;   /* Handle error */</div><div class="line"><a name="l00064"></a><span class="lineno">   64</span>&#160;}</div><div class="line"><a name="l00065"></a><span class="lineno">   65</span>&#160;```</div><div class="line"><a name="l00066"></a><span class="lineno">   66</span>&#160;</div><div class="line"><a name="l00067"></a><span class="lineno">   67</span>&#160;The newly created service configuration contains default settings for all configuration parameters and can be passed directly to the acc_service_create function. However, in most scenarios there is a need to change at least some of the configuration parameters. See acc_service_envelope.h and acc_base_configuration.h for a complete description of configuration parameters.</div><div class="line"><a name="l00068"></a><span class="lineno">   68</span>&#160;</div><div class="line"><a name="l00069"></a><span class="lineno">   69</span>&#160;### Profiles</div><div class="line"><a name="l00070"></a><span class="lineno">   70</span>&#160;</div><div class="line"><a name="l00071"></a><span class="lineno">   71</span>&#160;The services and detectors support profiles with different configuration of emission in the sensor. The different profiles provide an option to configure the wavelet length and optimize on either depth resolution or radar loop gain. More information regarding profiles can be read in the [sensor introduction document](https://acconeer-python-exploration.readthedocs.io/en/latest/sensor_introduction.html), https://acconeer-python-exploration.readthedocs.io/en/latest/sensor_introduction.html.</div><div class="line"><a name="l00072"></a><span class="lineno">   72</span>&#160;</div><div class="line"><a name="l00073"></a><span class="lineno">   73</span>&#160;![](fig_distance_resolution.png)</div><div class="line"><a name="l00074"></a><span class="lineno">   74</span>&#160;</div><div class="line"><a name="l00075"></a><span class="lineno">   75</span>&#160;The figure above shows the envelope signal of the same objects with two different profiles, one with short wavelet and one with longer.</div><div class="line"><a name="l00076"></a><span class="lineno">   76</span>&#160;</div><div class="line"><a name="l00077"></a><span class="lineno">   77</span>&#160;The Envelope service supports 5 different profiles which are defined in acc_service.h. Profile 1 has the shortest wavelet and should be used in applications which aim to see multiple objects or with short distance to the object. Profiles with higher numbers have longer wavelets and are more suitable to use in applications which aim to see objects with weak reflection or objects further away from the sensor. The highest profiles, 4 and 5, are optimized for maximum radar loop gain which leads to lower precision in the distance estimate.</div><div class="line"><a name="l00078"></a><span class="lineno">   78</span>&#160;</div><div class="line"><a name="l00079"></a><span class="lineno">   79</span>&#160;Profiles can be configured by the application by using a set function in the service api. The default profile is ACC_SERVICE_PROFILE_2.</div><div class="line"><a name="l00080"></a><span class="lineno">   80</span>&#160;</div><div class="line"><a name="l00081"></a><span class="lineno">   81</span>&#160;```c</div><div class="line"><a name="l00082"></a><span class="lineno">   82</span>&#160;void acc_service_profile_set(acc_service_configuration_t service_configuration,</div><div class="line"><a name="l00083"></a><span class="lineno">   83</span>&#160;                             acc_service_profile_t       profile);</div><div class="line"><a name="l00084"></a><span class="lineno">   84</span>&#160;```</div><div class="line"><a name="l00085"></a><span class="lineno">   85</span>&#160;</div><div class="line"><a name="l00086"></a><span class="lineno">   86</span>&#160;### Repetition Mode</div><div class="line"><a name="l00087"></a><span class="lineno">   87</span>&#160;</div><div class="line"><a name="l00088"></a><span class="lineno">   88</span>&#160;RSS supports two different repetition modes which configure the control flow of the sensor when it&#39;s producing data. In both modes, the application initiates the data transfer from the sensor and is responsible to keep the timing by fetching data from the service. The repetition modes are called on_demand and streaming and the default mode is on_demand.</div><div class="line"><a name="l00089"></a><span class="lineno">   89</span>&#160;</div><div class="line"><a name="l00090"></a><span class="lineno">   90</span>&#160;Repetition mode on_demand lets the application decide when the sensor produces data. This mode is recommended to be used if the application is not dependent of a fixed update rate and it&#39;s more important for the application to control the timing. An example could be if the application requests data at irregular time or with low frequency and it&#39;s more important to enable low power consumption. Repetition mode on_demand should also be used if the application set a length which requires stitching or want to use power save mode off.</div><div class="line"><a name="l00091"></a><span class="lineno">   91</span>&#160;</div><div class="line"><a name="l00092"></a><span class="lineno">   92</span>&#160;```c</div><div class="line"><a name="l00093"></a><span class="lineno">   93</span>&#160;void acc_base_configuration_repetition_mode_on_demand_set(acc_base_configuration_t configuration);</div><div class="line"><a name="l00094"></a><span class="lineno">   94</span>&#160;```</div><div class="line"><a name="l00095"></a><span class="lineno">   95</span>&#160;</div><div class="line"><a name="l00096"></a><span class="lineno">   96</span>&#160;Repetition mode streaming configures the sensor to produce data based on a hardware timer which is very accurate. It is recommended to use repetition mode streaming if the application requires very accurate timing. An example could be if the data should be processed with a fft. This mode can not be used it the application set a length which requires stitching.</div><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;</div><div class="line"><a name="l00098"></a><span class="lineno">   98</span>&#160;```c</div><div class="line"><a name="l00099"></a><span class="lineno">   99</span>&#160;void acc_base_configuration_repetition_mode_streaming_set(acc_base_configuration_t configuration, float update_rate);</div><div class="line"><a name="l00100"></a><span class="lineno">  100</span>&#160;```</div><div class="line"><a name="l00101"></a><span class="lineno">  101</span>&#160;</div><div class="line"><a name="l00102"></a><span class="lineno">  102</span>&#160;## Creating Service</div><div class="line"><a name="l00103"></a><span class="lineno">  103</span>&#160;</div><div class="line"><a name="l00104"></a><span class="lineno">  104</span>&#160;After the Envelope configuration has been prepared and populated with desired configuration parameters, the actual Envelope service instance must be created. During the creation step all configuration parameters are validated and the resources needed by RSS are reserved. This means that if the creation step is successful, we can be sure that it is possible to activate the service and get data from the sensor (unless there is some unexpected hardware error).</div><div class="line"><a name="l00105"></a><span class="lineno">  105</span>&#160;</div><div class="line"><a name="l00106"></a><span class="lineno">  106</span>&#160;```c</div><div class="line"><a name="l00107"></a><span class="lineno">  107</span>&#160;acc_service_handle_t handle = acc_service_create(envelope_configuration);</div><div class="line"><a name="l00108"></a><span class="lineno">  108</span>&#160;</div><div class="line"><a name="l00109"></a><span class="lineno">  109</span>&#160;if (handle == NULL)</div><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;{</div><div class="line"><a name="l00111"></a><span class="lineno">  111</span>&#160;   /* Handle error */</div><div class="line"><a name="l00112"></a><span class="lineno">  112</span>&#160;}</div><div class="line"><a name="l00113"></a><span class="lineno">  113</span>&#160;```</div><div class="line"><a name="l00114"></a><span class="lineno">  114</span>&#160;</div><div class="line"><a name="l00115"></a><span class="lineno">  115</span>&#160;During service create, the service run a calibration sequence on the sensor. The calibration is used once at create and can be used until the service is destroyed. A new calibration is needed if the environment is changed, such as deviation in temperature.</div><div class="line"><a name="l00116"></a><span class="lineno">  116</span>&#160;</div><div class="line"><a name="l00117"></a><span class="lineno">  117</span>&#160;If the service handle returned from acc_service_create is equal to NULL, then some setting in the configuration made it impossible for the system to create the service. One common reason is that the requested sweep length is too long or if the calibration fail, but in general, looking for error messages in the log is the best way to find out why a service creation failed.</div><div class="line"><a name="l00118"></a><span class="lineno">  118</span>&#160;</div><div class="line"><a name="l00119"></a><span class="lineno">  119</span>&#160;When the service has been created it is possible to get the actual number of samples (data_length) we will get for each result. This value can be useful when allocating buffers for storing the Envelope data.</div><div class="line"><a name="l00120"></a><span class="lineno">  120</span>&#160;</div><div class="line"><a name="l00121"></a><span class="lineno">  121</span>&#160;```c</div><div class="line"><a name="l00122"></a><span class="lineno">  122</span>&#160;acc_service_envelope_metadata_t envelope_metadata;</div><div class="line"><a name="l00123"></a><span class="lineno">  123</span>&#160;acc_service_envelope_get_metadata(handle, &amp;envelope_metadata);</div><div class="line"><a name="l00124"></a><span class="lineno">  124</span>&#160;</div><div class="line"><a name="l00125"></a><span class="lineno">  125</span>&#160;uint16_t data[envelope_metadata.data_length];</div><div class="line"><a name="l00126"></a><span class="lineno">  126</span>&#160;```</div><div class="line"><a name="l00127"></a><span class="lineno">  127</span>&#160;</div><div class="line"><a name="l00128"></a><span class="lineno">  128</span>&#160;It is now also possible to activate the service. This means that the radar sensor may start to produce data</div><div class="line"><a name="l00129"></a><span class="lineno">  129</span>&#160;</div><div class="line"><a name="l00130"></a><span class="lineno">  130</span>&#160;```c</div><div class="line"><a name="l00131"></a><span class="lineno">  131</span>&#160;if (!acc_service_activate(handle))</div><div class="line"><a name="l00132"></a><span class="lineno">  132</span>&#160;{</div><div class="line"><a name="l00133"></a><span class="lineno">  133</span>&#160;   /* Handle error */</div><div class="line"><a name="l00134"></a><span class="lineno">  134</span>&#160;}</div><div class="line"><a name="l00135"></a><span class="lineno">  135</span>&#160;```</div><div class="line"><a name="l00136"></a><span class="lineno">  136</span>&#160;</div><div class="line"><a name="l00137"></a><span class="lineno">  137</span>&#160;## Reading Envelope Data from the Sensor</div><div class="line"><a name="l00138"></a><span class="lineno">  138</span>&#160;</div><div class="line"><a name="l00139"></a><span class="lineno">  139</span>&#160;Envelope data is read from the sensor by a call to the function acc_service_envelope_get_next. This function blocks until the next sweep arrives from the sensor and the result is available in envelope_data.</div><div class="line"><a name="l00140"></a><span class="lineno">  140</span>&#160;</div><div class="line"><a name="l00141"></a><span class="lineno">  141</span>&#160;```c</div><div class="line"><a name="l00142"></a><span class="lineno">  142</span>&#160;uint16_t                           data[envelope_metadata.data_length];</div><div class="line"><a name="l00143"></a><span class="lineno">  143</span>&#160;acc_service_envelope_result_info_t result_info;</div><div class="line"><a name="l00144"></a><span class="lineno">  144</span>&#160;</div><div class="line"><a name="l00145"></a><span class="lineno">  145</span>&#160;for (int i = 0; i &lt; 10; i++)</div><div class="line"><a name="l00146"></a><span class="lineno">  146</span>&#160;{</div><div class="line"><a name="l00147"></a><span class="lineno">  147</span>&#160;   if (!acc_service_envelope_get_next(handle, data, envelope_metadata.data_length, &amp;result_info))</div><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;   {</div><div class="line"><a name="l00149"></a><span class="lineno">  149</span>&#160;           /* Handle error */</div><div class="line"><a name="l00150"></a><span class="lineno">  150</span>&#160;   }</div><div class="line"><a name="l00151"></a><span class="lineno">  151</span>&#160;}</div><div class="line"><a name="l00152"></a><span class="lineno">  152</span>&#160;```</div><div class="line"><a name="l00153"></a><span class="lineno">  153</span>&#160;</div><div class="line"><a name="l00154"></a><span class="lineno">  154</span>&#160;## Deactivating and Destroying the Service</div><div class="line"><a name="l00155"></a><span class="lineno">  155</span>&#160;</div><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;Call the acc_service_deactivate function to stop measurements.</div><div class="line"><a name="l00157"></a><span class="lineno">  157</span>&#160;</div><div class="line"><a name="l00158"></a><span class="lineno">  158</span>&#160;```c</div><div class="line"><a name="l00159"></a><span class="lineno">  159</span>&#160;if (!acc_service_deactivate(handle))</div><div class="line"><a name="l00160"></a><span class="lineno">  160</span>&#160;{</div><div class="line"><a name="l00161"></a><span class="lineno">  161</span>&#160;   /* Handle error */</div><div class="line"><a name="l00162"></a><span class="lineno">  162</span>&#160;}</div><div class="line"><a name="l00163"></a><span class="lineno">  163</span>&#160;```</div><div class="line"><a name="l00164"></a><span class="lineno">  164</span>&#160;</div><div class="line"><a name="l00165"></a><span class="lineno">  165</span>&#160;After the service has been deactivated it can be activated again to resume measurements or it can be destroyed to free up the resources associated with the service handle.</div><div class="line"><a name="l00166"></a><span class="lineno">  166</span>&#160;</div><div class="line"><a name="l00167"></a><span class="lineno">  167</span>&#160;```c</div><div class="line"><a name="l00168"></a><span class="lineno">  168</span>&#160;acc_service_destroy(&amp;handle);</div><div class="line"><a name="l00169"></a><span class="lineno">  169</span>&#160;```</div><div class="line"><a name="l00170"></a><span class="lineno">  170</span>&#160;</div><div class="line"><a name="l00171"></a><span class="lineno">  171</span>&#160;Finally, call acc_rss_deactivate when the application doesn’t need to access the Radar System Software anymore. This releases any remaining resources allocated in RSS.</div><div class="line"><a name="l00172"></a><span class="lineno">  172</span>&#160;</div><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;```c</div><div class="line"><a name="l00174"></a><span class="lineno">  174</span>&#160;acc_rss_deactivate();</div><div class="line"><a name="l00175"></a><span class="lineno">  175</span>&#160;```</div><div class="line"><a name="l00176"></a><span class="lineno">  176</span>&#160;</div><div class="line"><a name="l00177"></a><span class="lineno">  177</span>&#160;# How to Interpret the Envelope Data</div><div class="line"><a name="l00178"></a><span class="lineno">  178</span>&#160;</div><div class="line"><a name="l00179"></a><span class="lineno">  179</span>&#160;The Envelope data should be interpreted as a single one-dimensional array, where each array element represents the amplitude of the reflected signal from objects at a particular radial distance from the sensor.</div><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;</div><div class="line"><a name="l00181"></a><span class="lineno">  181</span>&#160;![](envelope.png)</div><div class="line"><a name="l00182"></a><span class="lineno">  182</span>&#160;</div><div class="line"><a name="l00183"></a><span class="lineno">  183</span>&#160;Assume that you have a setup with two objects like in the figure above. When plotting the Envelope data recorded using profile 1, which is optimized for maximum depth resolution, you will get a graph similar to the one below.</div><div class="line"><a name="l00184"></a><span class="lineno">  184</span>&#160;</div><div class="line"><a name="l00185"></a><span class="lineno">  185</span>&#160;![](envelope_profile_1.png)</div><div class="line"><a name="l00186"></a><span class="lineno">  186</span>&#160;</div><div class="line"><a name="l00187"></a><span class="lineno">  187</span>&#160;When a profile is choosen to improve radar loop gain, the radar sends out more energy, and the receiver has a higher gain setting which leads to a higher amplitude in the received signal. The internal filter parameters are also different which gives a smoother signal where noise and fine details have been removed. The graph below shows the same two objects as before but with profile 2 enabled.</div><div class="line"><a name="l00188"></a><span class="lineno">  188</span>&#160;</div><div class="line"><a name="l00189"></a><span class="lineno">  189</span>&#160;![](envelope_profile_2.png)</div><div class="line"><a name="l00190"></a><span class="lineno">  190</span>&#160;</div><div class="line"><a name="l00191"></a><span class="lineno">  191</span>&#160;## Envelope Metadata</div><div class="line"><a name="l00192"></a><span class="lineno">  192</span>&#160;</div><div class="line"><a name="l00193"></a><span class="lineno">  193</span>&#160;In addition to the array with Envelope data samples, a metadata data structure provides side information that can be useful when interpreting the Envelope data. This metadata can be retrieved after creating the service. It will not change during operation, so it is only needed to be retrieved once for the created service.</div><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;</div><div class="line"><a name="l00195"></a><span class="lineno">  195</span>&#160;```c</div><div class="line"><a name="l00196"></a><span class="lineno">  196</span>&#160;acc_service_envelope_metadata_t envelope_metadata;</div><div class="line"><a name="l00197"></a><span class="lineno">  197</span>&#160;acc_service_envelope_get_metadata(handle, &amp;envelope_metadata);</div><div class="line"><a name="l00198"></a><span class="lineno">  198</span>&#160;```</div><div class="line"><a name="l00199"></a><span class="lineno">  199</span>&#160;</div><div class="line"><a name="l00200"></a><span class="lineno">  200</span>&#160;The most important member variable in the meta data structure is data_length which holds the length of the Envelope data array. For other member variables see acc_service_envelope_metadata_t.</div><div class="line"><a name="l00201"></a><span class="lineno">  201</span>&#160;</div><div class="line"><a name="l00202"></a><span class="lineno">  202</span>&#160;## Envelope Result Info</div><div class="line"><a name="l00203"></a><span class="lineno">  203</span>&#160;</div><div class="line"><a name="l00204"></a><span class="lineno">  204</span>&#160;Result info is another kind of metadata which might change for each retrieved result. Result info is provided at the same time as the resulting array, either when calling get_next() or when a callback is triggered.</div><div class="line"><a name="l00205"></a><span class="lineno">  205</span>&#160;</div><div class="line"><a name="l00206"></a><span class="lineno">  206</span>&#160;```c</div><div class="line"><a name="l00207"></a><span class="lineno">  207</span>&#160;acc_service_envelope_result_info_t result_info;</div><div class="line"><a name="l00208"></a><span class="lineno">  208</span>&#160;acc_service_envelope_get_next(handle, data, data_length, &amp;result_info);</div><div class="line"><a name="l00209"></a><span class="lineno">  209</span>&#160;```</div><div class="line"><a name="l00210"></a><span class="lineno">  210</span>&#160;</div><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;The most important member variable is the sensor_communication_error which indicates whether a sensor communication has occurred. For other member variables see acc_service_envelope_result_info_t</div><div class="line"><a name="l00212"></a><span class="lineno">  212</span>&#160;</div><div class="line"><a name="l00213"></a><span class="lineno">  213</span>&#160;# Examples</div><div class="line"><a name="l00214"></a><span class="lineno">  214</span>&#160;</div><div class="line"><a name="l00215"></a><span class="lineno">  215</span>&#160;## Simple Distance Algorithm Example</div><div class="line"><a name="l00216"></a><span class="lineno">  216</span>&#160;</div><div class="line"><a name="l00217"></a><span class="lineno">  217</span>&#160;In this example we will implement a simple distance algorithm that finds the distance to the strongest reflecting object by finding the highest peak in the Envelope data.  We start by writing a function to find the index for the value in the Envelope data array with the highest amplitude.</div><div class="line"><a name="l00218"></a><span class="lineno">  218</span>&#160;</div><div class="line"><a name="l00219"></a><span class="lineno">  219</span>&#160;```c</div><div class="line"><a name="l00220"></a><span class="lineno">  220</span>&#160;int peak_index(uint16_t data[], uint16_t data_length)</div><div class="line"><a name="l00221"></a><span class="lineno">  221</span>&#160;{</div><div class="line"><a name="l00222"></a><span class="lineno">  222</span>&#160;    uint16_t max = 0;</div><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;    int peak_idx = 0;</div><div class="line"><a name="l00224"></a><span class="lineno">  224</span>&#160;    for (int i = 0 ; i&lt;data_length ; i++)</div><div class="line"><a name="l00225"></a><span class="lineno">  225</span>&#160;    {</div><div class="line"><a name="l00226"></a><span class="lineno">  226</span>&#160;        if (data[i] &gt; max )</div><div class="line"><a name="l00227"></a><span class="lineno">  227</span>&#160;        {</div><div class="line"><a name="l00228"></a><span class="lineno">  228</span>&#160;            max = data[i];</div><div class="line"><a name="l00229"></a><span class="lineno">  229</span>&#160;            peak_idx = i;</div><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;        }</div><div class="line"><a name="l00231"></a><span class="lineno">  231</span>&#160;    }</div><div class="line"><a name="l00232"></a><span class="lineno">  232</span>&#160;    return peak_idx;</div><div class="line"><a name="l00233"></a><span class="lineno">  233</span>&#160;}</div><div class="line"><a name="l00234"></a><span class="lineno">  234</span>&#160;```</div><div class="line"><a name="l00235"></a><span class="lineno">  235</span>&#160;</div><div class="line"><a name="l00236"></a><span class="lineno">  236</span>&#160;By using information on start and length in the meta data structure we can transform the index to a distance. To avoid measuring the distance to some peak in the background noise when there is no object in front of the sensor we define an amplitude threshold that must be exceeded in order to write out that we found a distance.</div><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;</div><div class="line"><a name="l00238"></a><span class="lineno">  238</span>&#160;```c</div><div class="line"><a name="l00239"></a><span class="lineno">  239</span>&#160;int peak_idx = peak_index(envelope_data, envelope_metadata.data_length);</div><div class="line"><a name="l00240"></a><span class="lineno">  240</span>&#160;unint16_t min_amplitude = 1000;</div><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;</div><div class="line"><a name="l00242"></a><span class="lineno">  242</span>&#160;if (envelope_data[peak_idx] &gt; min_amplitude)</div><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;{</div><div class="line"><a name="l00244"></a><span class="lineno">  244</span>&#160;   float dist =  envelope_metadata.start_m + peak_idx *</div><div class="line"><a name="l00245"></a><span class="lineno">  245</span>&#160;                 envelope_metadata.step_length_m;</div><div class="line"><a name="l00246"></a><span class="lineno">  246</span>&#160;   printf (&quot;distance: %f, amplitude %u\n&quot;, dist, envelope_data[peak_idx]);</div><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;}</div><div class="line"><a name="l00248"></a><span class="lineno">  248</span>&#160;else</div><div class="line"><a name="l00249"></a><span class="lineno">  249</span>&#160;{</div><div class="line"><a name="l00250"></a><span class="lineno">  250</span>&#160;   printf (&quot;amplitude under threshold\n&quot;);</div><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;}</div><div class="line"><a name="l00252"></a><span class="lineno">  252</span>&#160;```</div><div class="line"><a name="l00253"></a><span class="lineno">  253</span>&#160;</div><div class="line"><a name="l00254"></a><span class="lineno">  254</span>&#160;## Direct Leakage Measurement</div><div class="line"><a name="l00255"></a><span class="lineno">  255</span>&#160;</div><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;In this example we will outline how to set up the service to do a direct leakage measurement.</div><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;Note that only the configuration of the service is shown. Refer to previous chapters on how to create and activate the service and how to read out the service data.</div><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;</div><div class="line"><a name="l00259"></a><span class="lineno">  259</span>&#160;```c</div><div class="line"><a name="l00260"></a><span class="lineno">  260</span>&#160;acc_service_configuration_t envelope_configuration = acc_service_envelope_configuration_create();</div><div class="line"><a name="l00261"></a><span class="lineno">  261</span>&#160;</div><div class="line"><a name="l00262"></a><span class="lineno">  262</span>&#160;if (envelope_configuration == NULL)</div><div class="line"><a name="l00263"></a><span class="lineno">  263</span>&#160;{</div><div class="line"><a name="l00264"></a><span class="lineno">  264</span>&#160;   /* Handle error */</div><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;}</div><div class="line"><a name="l00266"></a><span class="lineno">  266</span>&#160;</div><div class="line"><a name="l00267"></a><span class="lineno">  267</span>&#160;acc_service_maximize_signal_attenuation_set(envelope_configuration, true); /* This is the main switch for performing direct leakage measurements */</div><div class="line"><a name="l00268"></a><span class="lineno">  268</span>&#160;</div><div class="line"><a name="l00269"></a><span class="lineno">  269</span>&#160;sweep_configuration = acc_service_get_sweep_configuration(envelope_configuration);</div><div class="line"><a name="l00270"></a><span class="lineno">  270</span>&#160;if (sweep_configuration == NULL)</div><div class="line"><a name="l00271"></a><span class="lineno">  271</span>&#160;{</div><div class="line"><a name="l00272"></a><span class="lineno">  272</span>&#160;   /* Handle error */</div><div class="line"><a name="l00273"></a><span class="lineno">  273</span>&#160;}</div><div class="line"><a name="l00274"></a><span class="lineno">  274</span>&#160;</div><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;acc_sweep_configuration_hw_accelerated_average_samples_set(sweep_configuration, 1); /* Sampling each data point one time is suitable for this measurement */</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;acc_sweep_configuration_receiver_gain_set(sweep_configuration, 0.09);               /* Lower the receiver gain to not saturate the signal */</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;acc_sweep_configuration_requested_range_set(sweep_configuration, -0.12, 0.12);      /* Set the range where the direct leakage is visible */</div><div class="line"><a name="l00278"></a><span class="lineno">  278</span>&#160;</div><div class="line"><a name="l00279"></a><span class="lineno">  279</span>&#160;/* Create, activate and read out the service data */</div><div class="line"><a name="l00280"></a><span class="lineno">  280</span>&#160;```</div></div><!-- fragment --></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="envelope_8md.html">envelope.md</a></li>
    <li class="footer">Generated on Mon Dec 2 2019 09:40:46 for Acconeer API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>

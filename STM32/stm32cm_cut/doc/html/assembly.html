<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Acconeer API: Assembly Test</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Acconeer API
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('assembly.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="headertitle">
<div class="title">Assembly Test </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>The assembly test can be used for two different purposes which both aim to verify the assembly of the sensor into a custom PCB:</p>
<ul>
<li>Flexible and accurate production test to maintain good quality in PCB assembly of the sensor</li>
<li>A tool for easy bring-up of HW/SW to decrease the time-to-market</li>
</ul>
<p>The assembly test contains several tests, where each test is focused on testing a particular functionality. The test purpose and interpretation of the test result is described in this document. The tests are structured to provide clear feedback on what in the assembly, implementation, and/or integration is failing.</p>
<p>Acconeer provides an example of how to use the assembly test: <a class="el" href="example__assembly__test_8c.html">example_assembly_test.c</a></p>
<h2>Disclaimer</h2>
<p>Assembly test should not be used on A111 with batch number 10467, 10457 or 10178 (also when mounted on XR111 and XR112).</p>
<h1>Setting up the Assembly Test</h1>
<h2>Initializing the System</h2>
<p>The Radar System Software (RSS) must be activated before any other calls are done. The activation requires a pointer to an <a class="el" href="structacc__hal__t.html" title="This struct contains the information about the sensor integration that RSS needs. ...">acc_hal_t</a> struct which contains information on the hardware integration and function pointers to hardware driver functions that are needed by RSS. See chapter 4 in the document “HAL Integration User Guide” for more information on how to integrate to the driver layer and populate the hal struct.</p>
<p>In Acconeer’s example integration towards STM32 and the drivers generated by the STM32Cube tool, there is a function acc_hal_integration_get_implementation to obtain the hal struct.</p>
<div class="fragment"><div class="line"><a class="code" href="structacc__hal__t.html">acc_hal_t</a> hal = <a class="code" href="acc__hal__integration_8h.html#a8b93eb4abdb9ad75250ca6404e0b412d">acc_hal_integration_get_implementation</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="group__RSS.html#ga478a45b4920777d3d4fc0f5fc8d05b58">acc_rss_activate</a>(&amp;hal))</div><div class="line">{</div><div class="line">        <span class="comment">/* Handle error */</span></div><div class="line">}</div></div><!-- fragment --><p>The corresponding code looks slightly different in software packages for the Raspberry Pi and other software packages from Acconeer where peripheral drivers for the host are included. The driver layer is first initialized by calling acc_driver_hal_init. The hal struct is then obtained with the function acc_driver_hal_get_implementation.</p>
<div class="fragment"><div class="line"><span class="keywordflow">if</span> (!acc_driver_hal_init())</div><div class="line">{</div><div class="line">        <span class="comment">/* Handle error */</span></div><div class="line">}</div><div class="line"></div><div class="line"><a class="code" href="structacc__hal__t.html">acc_hal_t</a> hal = acc_driver_hal_get_implementation();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (!<a class="code" href="group__RSS.html#ga478a45b4920777d3d4fc0f5fc8d05b58">acc_rss_activate</a>(&amp;hal))</div><div class="line">{</div><div class="line">        <span class="comment">/* Handle error */</span></div><div class="line">}</div></div><!-- fragment --><h2>Assembly Test Configuration</h2>
<p>Before the assembly test can be executed, we must prepare a test configuration. First a configuration is created.</p>
<div class="fragment"><div class="line"><a class="code" href="group__Assembly__test.html#gad4d2952b97efa2251f0897b063372328">acc_rss_assembly_test_configuration_t</a> assembly_test_configuration = <a class="code" href="group__Assembly__test.html#ga3ac4b1dd57d2b78a825012997334c909">acc_rss_assembly_test_configuration_create</a>();</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (assembly_test_configuration == NULL)</div><div class="line">{</div><div class="line">        <span class="comment">/* Handle error */</span></div><div class="line">}</div></div><!-- fragment --><p>All tests are enabled by default but the application can choose to run a subset of the tests by disabling tests in the configuration. <a class="el" href="acc__rss__assembly__test_8h.html">acc_rss_assembly_test.h</a> provides functions to disable individual tests</p>
<h1>Running the Assembly Test</h1>
<div class="fragment"><div class="line"><a class="code" href="structacc__rss__assembly__test__result__t.html">acc_rss_assembly_test_result_t</a> test_results[<a class="code" href="acc__rss__assembly__test_8h.html#aaa21d9a7586ce5f1fe3de6c341348a23">ACC_RSS_ASSEMBLY_TEST_MAX_NUMBER_OF_TESTS</a>];</div><div class="line">uint16_t                       nr_of_test_results = <a class="code" href="acc__rss__assembly__test_8h.html#aaa21d9a7586ce5f1fe3de6c341348a23">ACC_RSS_ASSEMBLY_TEST_MAX_NUMBER_OF_TESTS</a>;</div><div class="line"><span class="keywordtype">bool</span>                           success;</div><div class="line"></div><div class="line">success = <a class="code" href="group__Assembly__test.html#gaf5e1a05546f6504c977e9ccba0f354f0">acc_rss_assembly_test</a>(assembly_test_configuration, test_results, &amp;nr_of_test_results);</div><div class="line"></div><div class="line"><span class="keywordflow">if</span> (success)</div><div class="line">{</div><div class="line">        <span class="keywordflow">for</span> (uint16_t i = 0; i &lt; nr_of_test_results; i++)</div><div class="line">        {</div><div class="line">                <span class="keyword">const</span> <span class="keywordtype">bool</span> test_passed = test_results[i].<a class="code" href="structacc__rss__assembly__test__result__t.html#aa82bcbcb24d6e56f45e9d1fe2341314a">test_passed</a>;</div><div class="line">                printf(<span class="stringliteral">&quot;Name: %s, result: %s\n&quot;</span>, test_results[i].test_name, test_passed ? <span class="stringliteral">&quot;Pass&quot;</span> : <span class="stringliteral">&quot;Fail&quot;</span>);</div><div class="line">        }</div><div class="line">}</div><div class="line"><span class="keywordflow">else</span></div><div class="line">{</div><div class="line">        fprintf(stderr, <span class="stringliteral">&quot;Assembly test: Failed to complete\n&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><h1>Deactivation and Destroy</h1>
<p>After the test is finished, the configuration needs to be destroyed to release memory</p>
<div class="fragment"><div class="line"><a class="code" href="group__Assembly__test.html#gacc48fd76d79d1f3c92fae720a0a76d54">acc_rss_assembly_test_configuration_destroy</a>(&amp;configuration);</div></div><!-- fragment --><p>The system also needs to be deactivated to release its resources</p>
<div class="fragment"><div class="line"><a class="code" href="group__RSS.html#ga5221ed13d3d7aff540420aacfe55b5e2">acc_rss_deactivate</a>();</div></div><!-- fragment --><h1>Interpret the Assembly Test Result</h1>
<p>The different sub tests in the Assembly test aim to verify the integration of A111 into a custom PCB. The assembly test does not test the actual sensor but focus on testing the interaction. The assembly test returns an array with the result for each individual test and a variable containing the number of tests. The array should be iterated to check the result of each test and all tests should pass to confirm that the sensor and HAL has been integrated properly.</p>
<div class="fragment"><div class="line"><a class="code" href="structacc__rss__assembly__test__result__t.html">acc_rss_assembly_test_result_t</a> test_results[<a class="code" href="acc__rss__assembly__test_8h.html#aaa21d9a7586ce5f1fe3de6c341348a23">ACC_RSS_ASSEMBLY_TEST_MAX_NUMBER_OF_TESTS</a>];</div><div class="line">uint16_t                       nr_of_test_results = <a class="code" href="acc__rss__assembly__test_8h.html#aaa21d9a7586ce5f1fe3de6c341348a23">ACC_RSS_ASSEMBLY_TEST_MAX_NUMBER_OF_TESTS</a>;</div><div class="line"></div><div class="line"><span class="keywordflow">for</span> (uint16_t i = 0; i &lt; nr_of_test_results; i++)</div><div class="line">{</div><div class="line">        <span class="keyword">const</span> <span class="keywordtype">bool</span> test_passed = test_results[i].<a class="code" href="structacc__rss__assembly__test__result__t.html#aa82bcbcb24d6e56f45e9d1fe2341314a">test_passed</a>;</div><div class="line">        printf(<span class="stringliteral">&quot;Name: %s, result: %s\n&quot;</span>, test_results[i].test_name, test_passed ? <span class="stringliteral">&quot;Pass&quot;</span> : <span class="stringliteral">&quot;Fail&quot;</span>);</div><div class="line">}</div></div><!-- fragment --><p>The assembly test returns a pass or fail verdict and this can be used to find failing units. The debugging of failing tests is done with the assembly test's log, which provides details on each test to understand the root cause of why the test fails.</p>
<h2>Communication Test</h2>
<p>The first group of the assembly test checks that the communication with the sensor is functioning. The communication test is divided into three subtests:</p>
<h3>Read Test</h3>
<p>SPI bus communication is tested by reading data from the sensor. This basic test is useful in bring-up to reassure that the SPI driver and HAL registration is working properly. If the SPI bus is monitored using a logic analyzer, this is the pattern that should be observed (first 16 MISO bits may be integration dependent).</p>
<div class="image">
<img src="assembly_communication_read_test.png" alt="assembly_communication_read_test.png"/>
<div class="caption">
Assembly test, communication read test SPI pattern</div></div>
<p>{ width=100% }</p>
<h3>Write and read Test</h3>
<p>SPI bus communication is tested by writing and reading data on the sensor. The test contains a longer sequence of random bit pattern which is good to use for detecting glitches and runt pulses in the HW implementation that could increase the risk of communication failure. This test is also useful in bring-up to investigate the maximum stable SPI bit rate. The log also contains information on effective bit-rate and SPI frame overhead, which can be used as a guide on that the SPI driver is working properly.</p>
<h3>Interrupt Test</h3>
<p>The Interrupt pin connectivity is tested. This test is useful in bring-up to ensure that the Interrupt connectivity and pin selection in the HAL is correct. It also tests that the HAL function: acc_integration_wait_for_sensor_interrupt is working. In addition, the test also verifies the bandwidth requirement on the Interrupt path to ensure that no sensor Interrupts are lost.</p>
<h2>Supply Test</h2>
<p>The second group of the assembly test checks that the sensor is properly powered.</p>
<p>This test can be used in bring-up to ensure that all the power supplies (VIO_1-3) are valid during operation. If a power switch is implemented for VIO_1 and VIO_2, the test also ensures that the power switch control connectivity and pin selection in HAL is correct.</p>
<h2>Clock Test</h2>
<p>The third group of the assembly test checks that the reference clock for the sensor is valid. If the HW implementation includes an externally generated reference clock, the test also ensures that the clock control connectivity and pin selection in HAL is correct. If this test fails it could be that the specified reference frequency in the HAL does not match in actual frequency in the HW implementation. </p>
</div></div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="md__home_ai_jenkins_workspace_sw-main_0D2_doc_user_guides_rss_user_guide_main.html">User guides</a></li>
    <li class="footer">Generated on Mon Dec 2 2019 09:40:46 for Acconeer API by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.13 </li>
  </ul>
</div>
</body>
</html>
